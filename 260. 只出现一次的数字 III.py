class Solution:
        # 数组中有两个只出现一次的数，找出来
    def singleNumber(self, nums: List[int]) -> List[int]:
        # 时间复杂度O（n），空间复杂度O（1）的算法
        # 如果是数组中只出现一次的数，全数组异或即可
        # 现在考虑如何将数组分解：使得两个数组中个含一个只出现一次的数字，相同数组中其余的都是承兑出现的
        # 先将数组中的全部元素异或得到的结果：为两个只出现一次的数异或的结果：a^b
        # 将其转化成二进制，随便在a^b中找一个为1的位，利用这个位将数组分解成两个数组，该位为1的是一个数组，为0的为一个数组
        # 这样分解，将原本两两出现的数字肯定放在了一起，既然该位为1，那莫a和b在该位一定是一个为1一个为0，这样将他们也成功分解开了

        ret = functools.reduce(lambda x, y: x ^ y, nums)        #ret为整个数组异或的结果
        div = 1
        while div & ret == 0:       #找到最高位的1，退出时div就是 100……00
            div <<= 1
        a, b = 0, 0
        for n in nums:
            if n & div:             #该位为1时候
                a ^= n
            else:                   #为0时
                b ^= n
        return [a, b]


     ##还有例如排序、hash等算法，不过时间和空间复杂度一般