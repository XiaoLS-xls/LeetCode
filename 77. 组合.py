class Solution:
    def combine(self, n, k) :
        ######### 每一个元素都是取或者不取，两种情况
        temp = []
        ans = []
        def dfs(cur,n):
            if len(temp) + (n-cur+1)<k:  ##做一个剪枝，如果当前temp 的大小为s，未确定状态的区间[cur,n]的长度为t，
                return                   # 如果s+t<k，那么即使t个都被选中，也不可能构造出一个长度为k 的序列

            if len(temp) == k:        #记录合法的答案
                ans.append(temp[:])         ## temp[:]复制并不是指向
                return
            if cur == n+1:              #结束递归,可删除
                return
            temp.append(cur)
            dfs(cur+1,n)            #考虑选择当前位置
            temp.pop(-1)            ##弹出最后的元素
            dfs(cur+1,n)            #不考虑选择当前位置
        dfs(1,n)
        return ans

    ###方法2： 非递归（字典序法）实现组合型枚举
    ####     从n个元素中挑k个,如果变成二进制就是n个0,1组成的字符串，其中有k个1

    ######找到所有的结果的方法：  从 000011111  ————》   111110000      一种遍历的方法
    # 规则一：
    #     #末位为1时，从后开始找到第一个01，交换其顺序，即为一种结果   （其实就是将k个1往前推）
    # 规则二：                                                  （此时就将k个1分开了）
    #     #末位为0时，末尾有t个连续的0，而这t个连续的0之前有m个连续的1，
    #     #我们可以将倒数第t+m位置(连续1的最前边那个)的1和倒数第t+m+1位(前一个)的0对换，然后把倒数第t+1位到倒数第t+m−1位的1移动到最低位(最后的挪到最后)
    #例如:  n= 5, k = 3
        # 00111 -> 01011 -> 01101 -> 01110 -> 10011 -> 10101 ->10110 -> 11001 -> 11010 -> 11100